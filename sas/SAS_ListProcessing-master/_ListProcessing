/*%add_string 
    Purpose: Add a text string to each variable in a list as either a prefix or suffix.
    dependence: %num_tokens

    Required arguments: 
        words – the variable list 
        str – the text string to add to each variable in the &words list 

    Optional arguments: 
        location – whether to add the text string as a prefix or suffix [prefix|suffix, default: suffix] 
        delim – the character(s) separating each variable in the &words list [default: space] 

    Examples: 
        %put  %add_string(a b c, _max); *produces the text a_max b_max c_max;            
        %put %add_string(a b c, max_, location=prefix);     *produces the text max_a max_b max_c;            
        %put %add_string(%str(a,b,c), _max, delim=%str(,)); *produces the text a_max,b_max,c_max;

    Credit:
        source code from Robert J. Morris, Text Utility Macros for Manipulating Lists of Variable Names
          (SUGI 30, 2005) www2.sas.com/proceedings/sugi30/029-30.pdf           

*/


%macro add_string(words, str, delim=%str( ), location=suffix); 
    %local outstr i word num_words; 

    %* Verify macro arguments. ; 
    %if (%length(&words) eq 0) %then %do; 
        %put ***ERROR(add_string): Required argument 'words' is missing.; 
        %goto exit; 
    %end; 
    %if (%length(&str) eq 0) %then %do; 
        %put ***ERROR(add_string): Required argument 'str' is missing.; 
        %goto exit; 
    %end; 
    %if (%upcase(&location) ne SUFFIX and %upcase(&location) ne PREFIX) %then %do; 
        %put ***ERROR(add_string): Optional argument 'location' must be; 
        %put *** set to SUFFIX or PREFIX.; 
        %goto exit; 
    %end; 

    %* Build the outstr by looping through the words list and adding the 
    * requested string onto each word. ; 
    %let outstr = ; 
    %let num_words = %num_tokens(&words, delim=&delim); 
    %do i=1 %to &num_words; 
        %let word = %scan(&words, &i, &delim); 
        %if (&i eq 1) %then %do; 
            %if (%upcase(&location) eq PREFIX) %then %do; 
                %let outstr = &str&word; 
            %end; 
            %else %do; 
                %let outstr = &word&str; 
            %end; 
        %end; 
        %else %do; 
            %if (%upcase(&location) eq PREFIX) %then %do; 
                %let outstr = &outstr&delim&str&word; 
            %end; 
            %else %do; 
                %let outstr = &outstr&delim&word&str; 
            %end; 
        %end; 
    %end; 
    %* Output the new list of words. ; 
    &outstr 
    %exit: 
%mend add_string; 
/*<pre><b>
/ Program   : appmvar.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry (http://www.datasavantconsulting.com/roland/)
/ Date      : 23-Aug-2012
/ Purpose   : Function-style macro to append a string onto an existing macro
/             variable.
/ SubMacros : none
/ Notes     : This macro has very limited functionality and was written to make
/             your code less messy. It is where you are accumulating messages in
/             a macro variable and when you append onto the end of it you want
/             there to be a separating string to delimit the different messages
/             such as using %str(; ). This macro takes care of the logic of
/             checking what is already there and what you want to add and will
/             only use the separating string if the macro variable being
/             appended onto has contents as well as the string you are appending
/             is non-empty.
/ Usage     : %let err_msg=%appmvar(err_msg,This is another error message);
/             %let err_msg=%appmvar(err_msg,
/             Add this comma-delimited list (%nrbquote(&list)));
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ mvar              (pos) Name of macro variable to append onto
/ append            (pos) String to append
/ sep=%str(; )      Separating string (defaults to "; ")
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  23Aug12         new (v1.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/


%macro appmvar(mvar,append,sep=%str(; ));
  %if %length(&&&mvar) and %length(&append) %then %do;
&&&mvar&sep&append
  %end;
  %else %if %length(&append) %then %do;
&append
  %end;
  %else %do;
&&&mvar
  %end;
%mend appmvar;

/*<pre><b>
/ Program      : capmac.sas
/ Version      : 1.0
/ Author       : Roland Rashleigh-Berry (http://www.datasavantconsulting.com/roland/)
/ Date         : 11-Jan-2013
/ Purpose      : Function-style macro to capitalise the first letter of each
/                word in a macro string.
/ SubMacros    : %words %quotelst (%qlowcase from SI supplied autocall library
/                is called so this must be on the sasautos path).
/ Notes        : You can specify words to ignore. Case must match for these.
/                If the string you supply might contain commas or unbalanced
/                quotes then you should use %nrbquote() around it. See usage.
/ Usage        : %let tidy=%capmac(%nrbquote(A, B AND C'S RESULTS));
/                %put %capmac(%bquote(A, B AND C'S RESULTS)); 
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ string            (pos) Macro string to convert
/ ignore            List of strings (separated by spaces) to ignore
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  13Feb07         "macro called" message added
/ rrb  30Jul07         Header tidy
/ rrb  04May11         Code tidy
/ rrb  11Jan13         Header tidy. %lowcase removed from submacro list and
/                      use of %qlowcase documented. %nrbquote() recommended in
/                      place of %bquote() in Notes and Usage. Version number
/                      unchanged as no change made to the macro code (v1.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/


%macro capmac(string,ignore=);

  %local i igquote bit words;

  %if %length(&ignore) %then %let igquote=%quotelst(&ignore);
  %let words=%words(&string);

  %do i=1 %to &words;
    %let bit=%qscan(&string,&i,%str( ));
    %if %length(&ignore) %then %do;
      %if %index(&igquote,"%bquote(&bit)") %then %do;
&bit
        %goto done;
      %end;
    %end;
    %let bit=%qlowcase(&bit);
  
    %*- One character word -;
    %if %length(&bit) EQ 1 %then %do;
      %if &i EQ 1 %then %do;
%qupcase(&bit)
      %end;
      %else %if "%bquote(&bit)" EQ "a" %then %do;
a
      %end;
      %else %do;
%qupcase(&bit)
      %end;
     %end;
  
    %*- Longer than one character word -;
    %else %do;
      %*- always capitalise the first word -;
      %if &i EQ 1 %then %do;
%qupcase(%substr(&bit,1,1))%qsubstr(&bit,2)
      %end;
      %*- leave join words as lower text if not the last word -;
      %else %if %index("an" "and" "as" "at" "but" "by" "for" "in" "is" "it" "of"
                       "on" "or" "so" "that" "the" "to" "when" "with",
        "%bquote(&bit)") and (&i LT &words) %then %do;
&bit
      %end;
      %*- all other cases -;
      %else %do;
%qupcase(%substr(&bit,1,1))%qsubstr(&bit,2)
      %end;
    %end;
  
  %done:
  %end;

%mend capmac;
%macro changesep(
       l=           /* value list */
     , lv=          /* external variable override for value list */
     , lsep=%str( ) /* separator between values */
     , osep=%str(,) /* separator for rteurned list */
     ) ;
 
 /* L (or &LV) is list of quoted items separated by LSEP
 return unquoted list of items separated by OSEP
 LV provides override to specify external variable name instead list.
 If the LV option is used then L and CHG_: should be avoided for variable names.

 examples:
    %put %changesep ( l=a b c, lv= , lsep= %str( ), osep=%str(,) );

Credit:
    source code from Ian Whitlock, Names, Names, Names - Make Me a List
               (SGF 2007)   http://www2.sas.com/proceedings/forum2007/052-2007.pdf
               (SESUG 2008) http://analytics.ncsu.edu/sesug/2008/SBC-128.pdf
 */

 %local chg_list ;
 %if %length(&lv) = 0 %then
 %let lv = l ;
 %if %length(%superq(&lv)) > 0 %then
 %do ;
     %if %superq(osep)= %str( ) %then
     %do ;
         %let chg_list = %qsysfunc(strip(%superq(&lv))) ;
         %let chg_list = %qsysfunc(compbl(&chg_list)) ;
     %end ;
     %else
     %let chg_list = %superq(&lv) ;
     %let chg_list = %qsysfunc(translate(&chg_list,&osep,&lsep)) ;
 %end ;
 %unquote(&chg_list)
%mend changesep ;
/*Retrieving the number of words in a macro variable*/
/* valid in SAS 9.1 and above. */

/*
http://support.sas.com/kb/26/152.html
*/

%macro countw(L);
    %let countw=%sysfunc(countw(&L));
    %eval(&countw);
%mend countw;


/*example

%put %countw(e 5 5);

*/

/*<pre><b>
/ Program      : dequote.sas
/ Version      : 1.0
/ Author       : Roland Rashleigh-Berry (http://www.datasavantconsulting.com/roland/)
/ Date         : 04-May-2011
/ Purpose      : Function-style macro to remove front and end matching quotes
/                from a macro string and return the result.
/ SubMacros    : %qdequote
/ Notes        : This is a function-style macro that calls %qdequote and uses
/                %unquote to remove the macro quoting so that you can use it in
/                ordinary sas code.
/ Usage        : %let str=%dequote(%qreadpipe(echo '%username%'));
/                %put  %dequote(%qreadpipe(echo '%username%')); 
/                
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ str               (pos) Macro string to dequote
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/


%macro dequote(str);
%unquote(%qdequote(&str))
%mend dequote;


/*<pre><b>
/ Program   : dir.sas
/ Version   : 1.1
/ Author    : Roland Rashleigh-Berry (http://www.datasavantconsulting.com/roland/)
/ Date      : 26-Jun-2011
/ Purpose   : Function-style macro to return a list of members of a directory
/             on a WINDOWS platform according to the file pattern you supply.
/             If you supply just the directory name then all members are
/             listed. This runs the MSDOS command in the form "dir /B mydir"
/ SubMacros : %qreadpipe
/ Notes     : Just the file names are returned unquoted. If you need the full
/             path name in double quotes then use the %dirfpq macro instead
/             which will correctly handle file names containing spaces.
/ Usage     : %let dirlist=%dir(C:\utilmacros);
/             %let dirlist=%dir(C:\utilmacros\*.sas);
/             %put dirlist=%dir(d:\test);
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ dir               (pos) Directory path name (no quotes)
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  26Jun11         Remove quotes if supplied (v1.1)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/


%macro dir(dir);
  %unquote(%qreadpipe(dir /B %sysfunc(dequote(&dir))))
%mend dir;

/*<pre><b>
/ Program   : dirfpq.sas
/ Version   : 1.1
/ Author    : Roland Rashleigh-Berry (http://www.datasavantconsulting.com/roland/)
/ Date      : 26-Jun-2011
/ Purpose   : Function-style macro to return a list of full-path quoted members
/             of a directory on a Windows platform according to the file pattern
/             you supply.
/ SubMacros : %qreadpipe
/ Notes     : Members are shown with the full path names in double quotes. If a
/             file name contains spaces then this will be correctly quoted. You
/             MUST give the full file pattern and not just the directory as this
/             does not use the DIR command to act on the directory but rather
/             expands the file pattern.
/ Usage     : %let dirlist=%dirfpq(C:\utilmacros);     %*- NO GOOD -;
/             %let dirlist=%dirfpq(C:\utilmacros\*);      %*- GOOD -;
/             %let dirlist=%dirfpq(C:\utilmacros\*.sas);  %*- GOOD -;
/             %put %dirfpq(d:\test\*.gif);
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ dir               (pos) Directory path name with file pattern (no quotes)
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  26Jun11         Remove quotes if supplied (v1.1)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/


%macro dirfpq(dir);
%unquote(%qreadpipe(echo off & for %nrstr(%f) in (%sysfunc(dequote(&dir))) do echo "%nrstr(%f)"))
%mend dirfpq;

 
/*<pre><b>
/ Program   : editlist.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry (http://www.datasavantconsulting.com/roland/)
/ Date      : 01-Nov-2012
/ Purpose   : Function-style macro to allow you to edit a list of space 
/             delimited items.
/ SubMacros : none
/ Notes     : This macro is for tasks like generating rename statements where a
/             repeat of items in a list is required (see usage notes). The edit
/             string must be enclosed in single quotes. Elements of the list
/             are written to the macro variable "item" which can be referenced
/             in the edit string. If semicolons form part of the edit string
/             then for certain uses these can be protected using %nrstr().
/
/             If used in sas code you might need to %unquote() the final string.
/
/             This macro is essentially the same as the %doallitem macro but
/             giving a different usage emphasis and with no submacros.
/
/ Usage     : %put >>> %editlist(aa bb cc dd,'&item=mr_&item');
/             %put >>> %editlist(xx_aa xx_bb xx_cc,
/             '&item=%substr(&item,4)');
/             %put >>> %editlist(xx_aa xx_bb xx_cc,
/             '%substr(&item,4)=&item%nrbquote(;)');
/
/             (will write to log:)
/             >>> aa=mr_aa bb=mr_bb cc=mr_cc dd=mr_dd
/             >>> xx_aa=aa xx_bb=bb xx_cc=cc
/             >>> aa=xx_aa; bb=xx_bb; cc=xx_cc;
/             %put >>> %editlist(aa bb cc dd,'&item=mr_&item');
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ list              (pos) List of space delimited items
/ editstr           (pos) Edit string (in single quotes)
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  31Oct12         New (v1.0)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/


%macro editlist(list,editstr);
  %local i item;
  %let i=1;
  %let item=%scan(&list,&i,%str( ));
  %do %while(%length(&item));
%sysfunc(dequote(&editstr))
    %let i=%eval(&i + 1);
    %let item=%scan(&list,&i,%str( ));
  %end;
%mend editlist;
%macro for(macro_var_list,in=,do=);

/* 
http://www.sascommunity.org/wiki/Streamlining_Data-Driven_SAS_With_The_%25FOR_Macro
http://www.wuss.org/proceedings08/08WUSS%20Proceedings/papers/app/app04.pdf

  Function: This macro performs a loop generating SAS code.  It
    proceeds sequentially through one of 5 kinds of data objects: 
    SAS dataset, value list, number range, dataset contents and
    directory contents.  Data object values are assigned to macro 
    variables specified in macro_var_list upon each loop iteration. 
    
    Example:
     
      %for(hospid hospname, in=[report_hosps], do=%nrstr(
          title "&hospid &hospname Patient Safety Indicators";
          proc print data=psi_iqi(where=(hospid="&hospid")); run;
      ))

  The example above loops over the dataset "report_hosps", which 
  has dataset variables "hospid" and "hospname".  For each dataset
  observation, macro variables &hospid and &hospname are assigned 
  values from the identically named dataset variables and the loop 
  code is generated, which in the example prints a report.
    
  Parameters: 
    macro_var_list = space-separated list of macro variable names
              to be assigned values upon each loop iteration. 
    in      = Data object to access.  Object type is distinguished
              by choice of brackets (or no backets for a range):
                  (a b c)  - a space-separated value list whose
                             values are sequentially accessed.
                  [xyz]    - a SAS dataset whose observations are
                             sequentially accessed.
                  {xyz}    - a SAS dataset whose variable descriptions
                             (proc contents) are sequentially accessed.
                  <c:\abc> - a directory path whose file descriptions
                             are sequentially accessed.
                  1:100    - a number range whose values are 
                             sequentially accessed.
    do      = The SAS code to be generated for each iteration of
              the %for macro.  If macro variable substitution is
              to be done in the loop code (the typical case) enclose 
              the code in a %nrstr() macro call to defer macro
              substitution to loop generation time.
  
    For dataset [ ] iterations:
    The dataset name can be qualified with a libname and where clause.
    For each observation in the dataset, all macro variables in the
    macro_var_list are assigned values of identically named dataset 
    variables and the "do=" SAS code is generated. 
    
    For dataset contents { } iterations:
    The dataset name can be qualified with a libname.
    For each variable in the dataset, the macro variables in the
    macro_var_list are assigned values to describe the dataset
    variable and the "do=" SAS code is generated.  Valid names in
    macro_var_list are "name", "type", "length", "format" and "label".
        name   - is set to the variable name
        type   - is set to 1 for numeric variables and 2 for
                 character variables.
        format - is set to the variable format
        length - is set to the variable length
        label  - is set to the variable label
    
    For directory < > iterations:
    For each file in the directory, the macro variables in the
    macro_var_list are assigned values to describe a directory
    file and the "do=" SAS code is generated.  Valid names in
    macro_var_list are "filepath", "filename", "shortname", 
    "extension", and "isdir". 
        filepath - full pathname of file
        filename - filename with extension
        shortname - filename without extension
        extension - file extension
        isdir  - 1 if file is directory, else 0 
    
    For value list ( ) iterations:
    Space is the default value separator.  Enclose other separator 
    characters in nested parentheses, e.g., in=((|)Joe Jones|Al Smith) 
    The variables named in macro_var_list are assigned successive values
    from the value list. When all variables are assigned, the "do=" SAS
    code is generated.  The process repeats until the end of value list is
    reached.  If the end of value list is reached before all variables in
    macro_var_list are assigned values, then the iteration is terminated
    without generating the "do=" code on the partially assigned variables
    (the number of values in the value list should be a multiple of the
    number of names in macro_var_list).
    
    For range : iterations:
    A range with 2 numbers uses a single colon and has an implied
    increment of 1.  For a range with 3 numbers (e.g., in=1:11:2),
    the final number is the increment. The first variable in the 
    macro_var_list is assigned values as it would be by a 
    %do-%to-%by statement.
    
    NOTE: Macro variable values obtained from datasets remain unquoted 
    when they contain only letters, digits, whitespace, '_' and '.', 
    otherwise they are quoted.  Values obtained from value list are 
    always unquoted.

  Author: Jim Anderson, UCSF, james.anderson@ucsf.edu
    "Please keep, use and pass on the %for macro 
     with this authorship note.  -Thanks "

  Please send improvements, fixes or comments to Jim Anderson.

*/

  %local _for_itid _for_ct _for_do _for_i _for_val1 _for_var1 _n_ 
         _for_dir _for_var_num _for_in_first _for_in_last _for_in_length 
         _for_in_sep _for_in_values _for_in_more _for_extra;  
  %let _for_do=&do;
  %if %eval(%index(&do,%nrstr(%if))+%index(&do,%nrstr(%do))) %then
  %do; %* conditional macro code - need to embed in macro;
    %global _for_gen;
    %if &_for_gen=%str( ) %then %let _for_gen=0;
    %else %let _for_gen=%eval(&_for_gen+1);
    %unquote(%nrstr(%macro) _for_loop_&_for_gen(); &do %nrstr(%mend;))
    %let _for_do=%nrstr(%_for_loop_)&_for_gen();
  %end;
  %let _for_ct=0;
  %let _for_in_first=%qsubstr(&in,1,1);
  %let _for_in_length=%length(&in);
  %let _for_in_last=%qsubstr(&in,&_for_in_length,1);
  %if &_for_in_first=%qsubstr((),1,1) %then
  %do; %* loop over value list;
  	%if &_for_in_last ne %qsubstr((),2,1) %then
  	%do;
  		%put ERROR: "for" macro "in=(" missing terminating ")";
  		%return;
  	%end;
    %if &macro_var_list=%str( ) %then
    %do; %*empty variable list - perhaps (s)he just wants &_n_;
      %let macro_var_list=_for_extra;
    %end;
  	%if %qsubstr(&in,2,1) ne &_for_in_first %then
  	%do; %* implicit space separator -- empty entries disallowed;
  	  %if &_for_in_length<3 %then %return;
  	  %let _for_in_values=%substr(&in,2,%eval(&_for_in_length-2));
      %local _for_value_index;
      %let _for_value_index=1;
      %do %while(1);
        %let _for_ct=%eval(&_for_ct+1);
        %let _n_=&_for_ct;
      	%let _for_i=1;
      	%let _for_var1=%scan(&macro_var_list,1,%str( ));
      	%do %while(%str(&_for_var1) ne %str( ));
      	  %let _for_val1=%scan(&_for_in_values,&_for_value_index,%str( ));
      	  %let _for_value_index=%eval(&_for_value_index+1);
      	  %if %length(&_for_val1)=0 %then
      	  %do; %* end of values before end of variables, terminate iteration;
            %return;
          %end;
      	  %let &_for_var1=&_for_val1;
      	  %let _for_i=%eval(&_for_i+1);
      	  %let _for_var1=%scan(&macro_var_list,&_for_i,%str( ));
      	%end;
  %unquote(&_for_do)
      %end;
      %return;
  	%end;
  	%else
  	%do; %* explicit separator -- empty entries allowed;
  		%if &_for_in_length<6 %then %return; %* empty list;
  		%let _for_in_sep=%qsubstr(&in,3,1);
  		%if %qsubstr(&in,4,1) ne &_for_in_last %then
  		%do;
  			%put ERROR: "for" macro "in=" explicit separator missing right parenthesis;
  			%return;
  		%end;
  		%let _for_in_values=%qleft(%qtrim(%qsubstr(&in,5,%eval(&_for_in_length-5))));
	    %let _for_in_more=1;
	    %do %while(1);
	      %let _for_ct=%eval(&_for_ct+1);
	      %let _n_=&_for_ct;
	    	%let _for_i=1;
	    	%let _for_var1=%scan(&macro_var_list,1,%str( ));
	    	%do %while(%str(&_for_var1) ne %str( ));
		  		%if &_for_in_more=0 %then %return; %* end of value list;
          %if &_for_in_sep=%qsubstr(&_for_in_values,1,1) %then %let &_for_var1=;
	    	  %else %let &_for_var1=%scan(&_for_in_values,1,&_for_in_sep);
	    	  %let _for_i=%eval(&_for_i+1);
	    	  %let _for_var1=%scan(&macro_var_list,&_for_i,%str( ));
	    	  %let _for_in_more=%index(&_for_in_values,&_for_in_sep);
          %if %length(&_for_in_values)=&_for_in_more %then %let _for_in_values=%str( );
	    	  %else %let _for_in_values=%qsubstr(&_for_in_values,%eval(&_for_in_more+1));
	    	%end;
	%unquote(&_for_do)
	    %end;
	    %return;
  	%end;
  %end;
  %else %if &_for_in_first=%str([) %then
  %do; %* loop over dataset;
    %local _for_in_dataset;
  	%if &_for_in_last ne %str(]) %then
  	%do;
  		%put ERROR: "for" macro "in=[" missing terminating "]";
  		%return;
  	%end;
  	%if &_for_in_length<3 %then %return;
  	%let _for_in_dataset=%substr(&in,2,%eval(&_for_in_length-2));
	  %let _for_itid=%sysfunc(open(&_for_in_dataset));
	  %if &_for_itid=0 %then
	  %do;
	    %put ERROR: for macro cant open dataset &_for_in_dataset;
	    %return;
	  %end;
    %do %while(%sysfunc(fetch(&_for_itid,NOSET))>=0);
      %let _for_ct=%eval(&_for_ct+1);
      %let _n_=&_for_ct;
    	%let _for_i=1;
    	%let _for_var1=%scan(&macro_var_list,1,%str( ));
    	%do %while(%str(&_for_var1) ne %str( ));
    	  %let _for_var_num=%sysfunc(varnum(&_for_itid,&_for_var1));
    	  %if &_for_var_num=0 %then
    	  %do;
    	    %put ERROR: "&_for_var1" is not a dataset variable;
    	    %return; 
    	  %end;
    	  %if %sysfunc(vartype(&_for_itid,&_for_var_num))=C %then
    	  %do; %* character variable;
    	    %let _for_val1=%qsysfunc(getvarc(&_for_itid,&_for_var_num));
      	  %if %sysfunc(prxmatch("[^\w\s.]+",&_for_val1)) %then
      	    %let &_for_var1=%qtrim(&_for_val1);
      	  %else
      	    %let &_for_var1=%trim(&_for_val1);
    	  %end;
    	  %else
    	  %do; %* numeric variable;
    	    %let &_for_var1=%sysfunc(getvarn(&_for_itid,&_for_var_num));
    	  %end;
    	  %let _for_i=%eval(&_for_i+1);
    	  %let _for_var1=%scan(&macro_var_list,&_for_i,%str( ));
    	%end;
%unquote(&_for_do)
    %end;
	  %let _for_i=%sysfunc(close(&_for_itid));
    %return;
  %end;
  %else %if &_for_in_first=%str({) %then
  %do; %* loop over proc contents;
    %local _for_in_dataset;
  	%if &_for_in_last ne %str(}) %then
  	%do;
  		%put ERROR: "for" macro "in={" missing terminating "}";
  		%return;
  	%end;
  	%if &_for_in_length<3 %then %return;
  	%let _for_in_dataset=%substr(&in,2,%eval(&_for_in_length-2));
	  %let _for_itid=%sysfunc(open(&_for_in_dataset));
	  %if &_for_itid=0 %then
	  %do;
	    %put ERROR: for macro cant open dataset &_for_in_dataset;
	    %return;
	  %end;
	  %let _for_ct = %sysfunc(attrn(&_for_itid,NVARS));
    %do _for_i=1 %to &_for_ct;
      %let _n_=&_for_i;
    	%let _for_var_num=1;
    	%let _for_var1=%upcase(%scan(&macro_var_list,1,%str( )));
    	%do %while(%str(&_for_var1) ne %str( ));
    	  %if &_for_var1=NAME %then
    	  %do;
    	    %let name=%sysfunc(varname(&_for_itid,&_for_i));
    	  %end;
    	  %else %if &_for_var1=FORMAT %then
    	  %do;
    	    %let format=%sysfunc(varfmt(&_for_itid,&_for_i));
    	  %end;
    	  %else %if &_for_var1=TYPE %then
    	  %do;
    	    %if %sysfunc(vartype(&_for_itid,&_for_i))=C %then
    	      %let type=2;
    	    %else
    	      %let type=1;
    	  %end;
    	  %else %if &_for_var1=LENGTH %then
    	  %do;
    	    %let length=%sysfunc(varlen(&_for_itid,&_for_i));
    	  %end;
    	  %else %if &_for_var1=LABEL %then
    	  %do;
    	    %let _for_val1=%qsysfunc(varlabel(&_for_itid,&_for_i));
      	  %if %sysfunc(prxmatch("[^\w\s.]+",&_for_val1)) %then
      	    %let label=%qtrim(&_for_val1);
      	  %else
      	    %let label=%trim(&_for_val1);
    	  %end;
    	  %else
    	  %do;
    	    %put ERROR: "&_for_var1" is not NAME, TYPE, FORMAT, LENGTH or LABEL;
    	    %return; 
    	  %end;
    	  %let _for_var_num=%eval(&_for_var_num+1);
    	  %let _for_var1=%upcase(%scan(&macro_var_list,&_for_var_num,%str( )));
    	%end;
%unquote(&_for_do)
    %end;
	  %let _for_i=%sysfunc(close(&_for_itid));
    %return;
  %end;  
  %else %if &_for_in_first=%str(<) %then
  %do; %* loop over directory contents;
  	%if &_for_in_last ne %str(>) %then
  	%do;
  		%put ERROR: "for" macro "in=<" missing terminating ">";
  		%return;
  	%end;
    %let _for_val1=;
  	%if &_for_in_length<3 %then %return;
    %let _for_dir=%substr(&in,2,%eval(&_for_in_length-2));
	  %let _for_itid=%sysfunc(filename(_for_val1,&_for_dir));
	  %let _for_itid=%sysfunc(dopen(&_for_val1));
	  %if &_for_itid=0 %then
	  %do;
	    %put ERROR: cant open directory path=&_for_dir;
	    %return;
	  %end;
	  %let _for_ct = %sysfunc(dnum(&_for_itid));
    %do _for_i=1 %to &_for_ct;
      %let _n_=&_for_i;
    	%let _for_var_num=1;
    	%let _for_var1=%upcase(%scan(&macro_var_list,1,%str( )));
    	%do %while(%str(&_for_var1) ne %str( ));
    	  %let _for_extra=%sysfunc(dread(&_for_itid,&_for_i));
    	  %if &_for_var1=FILENAME %then
    	  %do;
    	    %let filename=&_for_extra;
    	  %end;
    	  %else %if &_for_var1=EXTENSION %then
    	  %do;
    	    %if %index(&_for_extra,%str(.)) ne 0 %then
    	    %do;
    	      %let extension=.%scan(&_for_extra,-1,%str(.));
    	    %end;
    	    %else
    	    %do;
    	      %let extension=;
    	    %end;
    	  %end;
    	  %else %if &_for_var1=FILEPATH %then
    	  %do;
    	    %let filepath=&_for_dir\&_for_extra; %*windows specific;
    	  %end;
    	  %else %if &_for_var1=SHORTNAME %then
    	  %do;
    	    %if %index(&_for_extra,%str(.)) ne 0 %then
    	    %do;
    	      %let _for_val1=%eval(%length(&_for_extra)-
    	               %length(%scan(&_for_extra,-1,%str(.)))-1);
    	      %let shortname=%substr(&_for_extra,1,&_for_val1);
    	    %end;
    	    %else
    	    %do;
    	      %let shortname=&_for_extra;
    	    %end;
    	  %end;
    	  %else %if &_for_var1=ISDIR %then
    	  %do; %*below windows specific;
    	    %let _for_var1=_forfile;
    	    %let _for_val1=%sysfunc(filename(_for_var1,&_for_dir\&_for_extra));
    	    %let _for_val1=%sysfunc(dopen(&_for_var1));
    	    %let isdir=%eval(&_for_val1 ne 0);
    	    %if &isdir %then 
    	    %do; 
    	      %let _for_val1=%sysfunc(dclose(&_for_val1));
    	    %end;
    	  %end;
    	  %else
    	  %do;
    	    %put ERROR: "&_for_var1" is not FILENAME, EXTENSION, FILEPATH, SHORTNAME or ISDIR;
    	    %return; 
    	  %end;
    	  %let _for_var_num=%eval(&_for_var_num+1);
    	  %let _for_var1=%upcase(%scan(&macro_var_list,&_for_var_num,%str( )));
    	%end;
%unquote(&_for_do)
    %end;
	  %let _for_i=%sysfunc(dclose(&_for_itid));
	  %let _for_i=%sysfunc(filename(_for_val1,));
    %return;
  %end;
  %else %if %index(&in,%str(:)) %then
  %do; %* loop from:to:by;
    %local _for_in_from _for_in_to _for_in_by;
    %let _for_in_from=%scan(&in,1,%str(:));
    %let _for_in_to=%scan(&in,2,%str(:));
    %if &_for_in_to=%str( ) %then 
    %do;
      %put ERROR: for macro missing value after : in range;
      %return;
    %end;
    %let _for_in_by=%scan(&in,3,%str(:));
    %if &_for_in_by=%str( ) %then %let _for_in_by=1;
    %let _for_var1=%scan(&macro_var_list,1,%str( ));
    %let _for_ct=1;
    %do _for_i=&_for_in_from %to &_for_in_to %by &_for_in_by;
      %let _n_=&_for_ct;
    	%if %str(&_for_var1) ne %str( ) %then %let &_for_var1=&_for_i;
    	%let _for_ct=%eval(&_for_ct+1);
%unquote(&_for_do)
    %end;
    %return;
  %end;
  
  %put ERROR: for macro unrecognized in= argument value "&in";
%mend for;/*
Purpose: return the list of variables in a data set

Examples:
    %put %getVar(%str(sashelp.class));
    %put %getVar(%str(sashelp.class),n);
    %put %getVar(%str(sashelp.class),N);
    %put %getVar(%str(sashelp.class),c);
    %put %getVar(%str(sashelp.class),C);

Credits:
    Source code by Arthur Carpenter, Storing and Using a List of Values in a Macro Variable
         http://www2.sas.com/proceedings/sugi30/028-30.pdf
    Authored by Michael Bramley
    Jiangtang Hu (2013, Jiangtanghu.com) adds variable type (N, C) options.
	
	
	updated in http://www.sascommunity.org/wiki/Macro_VarList
*/


%macro getVar(dset,type) ; 
   %local varlist ; 
    %let fid = %sysfunc(open(&dset)) ; 
    %if &fid %then %do ; 
        %do i=1 %to %sysfunc(attrn(&fid,nvars)) ; 
            %if %upcase(&type) = N %then %do;
                %if %sysfunc(vartype(&fid,&i)) = N %then
                    %let varlist= &varlist %sysfunc(varname(&fid,&i));
            %end;
            %else %if %upcase(&type) = C %then %do;
                %if %sysfunc(vartype(&fid,&i)) = C %then
                    %let varlist= &varlist %sysfunc(varname(&fid,&i));
            %end;
            %else
                %let varlist= &varlist %sysfunc(varname(&fid,&i)); 
        %end ; 
        %let fid = %sysfunc(close(&fid)) ; 
    %end ; 
    &varlist 
%mend getVar ;



/*
%put %get_label(sashelp.iris,SepalLength);
*/

%macro get_label(data,variable);
	%local label;  
   	%let dsid = %sysfunc(open(&data));
  	%if &dsid %then %do;
         %let label=%sysfunc(varlabel(&dsid,%sysfunc(varnum(&dsid,&variable))));
         %let rc = %sysfunc(close(&dsid));		
   	%end;
    &label;
%mend;  


/*<pre><b>
/ Program   : match.sas
/ Version   : 2.0
/ Author    : Roland Rashleigh-Berry (http://www.datasavantconsulting.com/roland/)
/ Date      : 03-Dec-2012
/ Purpose   : Function-style macro to return elements of a list that match those
/             in a reference list.
/ SubMacros : %words %nodup
/ Notes     : Non-matching list elements are returned in the global macro
/             variable _nomatch_ .
/ Usage     : %let match=%match(aa bb,aa cc);
/             %put %match(aa bb,aa cc); 
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ ref               (pos) Space-delimited reference list
/ list              (pos) Space-delimited list
/ nodup=yes         By default, remove duplicates from the list
/ casesens=no       By default, case sensitivity is not important.
/ fixcase=no        By default, do not make the case of matching items the same
/                   as the item in the reference list.
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  19Mar07         Macro called message added plus header tidy
/ rrb  30Jul07         Header tidy
/ rrb  01May11         Code restructured and missing list allowed (v2.0)
/ rrb  03Dec12         Header tidy (%nodup added to submacro list)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/


%macro match(ref,list,nodup=yes,casesens=no,fixcase=no);
  %local err errflag list2 nref nlist i j item match refitem;
  %let err=ERR%str(OR);
  %let errflag=0;

  %global _nomatch_;
  %let _nomatch_=;

  %if not %length(&nodup) %then %let nodup=yes;
  %if not %length(&casesens) %then %let casesens=no;
  %if not %length(&fixcase) %then %let fixcase=no;

  %let nodup=%upcase(%substr(&nodup,1,1));
  %let casesens=%upcase(%substr(&casesens,1,1));
  %let fixcase=%upcase(%substr(&fixcase,1,1));

  %if "&nodup" EQ "Y" %then %let list2=%nodup(&list,casesens=&casesens);
  %else %let list2=&list;

  %let nref=%words(&ref);
  %let nlist=%words(&list2);

  %if not &nref %then %do;
    %put &err: (match) No elements in reference list;
    %let errflag=1;
  %end;

  %if &errflag %then %goto exit;

  %if not &nlist %then %goto skip;

  %do i=1 %to &nlist;
    %let item=%scan(&list2,&i,%str( ));
    %let match=NO;
    %do j=1 %to &nref;
      %let refitem=%scan(&ref,&j,%str( ));
      %if "&casesens" EQ "N" %then %do;
        %if "%upcase(&item)" EQ "%upcase(&refitem)" %then %do;
          %let match=YES;
          %let j=&nref;
        %end;
      %end;
      %else %do;
        %if "&item" EQ "&refitem" %then %do;
          %let match=YES;
          %let j=&nref;
        %end;
      %end;
    %end;
    %if &match EQ YES %then %do;
      %if "&fixcase" EQ "N" %then &item;
      %else &refitem;
    %end;
    %else %let _nomatch_=&_nomatch_ &item;
  %end;

  %goto skip;
  %exit: %put &err: (match) Leaving macro due to problem(s) listed.;
  %skip:
%mend match;

/*http://listserv.uga.edu/cgi-bin/wa?A2=ind9907C&L=sas-l&P=R1337
Dorfman:

%LET LIST =
SG FJLKDSN GEWO OPITHUI GJSERO TNJEOWIJ TW9345Y TWES SDJGJSRL NWOITJN RET
POTREPOR _5TWT WPST NWP4 T924YW P9YTP9W4 NT599P DLKFGBLK SDGSGIW A AEG AEF ZG
EGH A G HA HESH AIT4Y8W3 HAW T83PTQ3Y O OYTP53YT PQYP8Y3Q SSLKGH SLIEUH AERH
DQLUEIUR SL SLSHIH4 AEK AH5WO TA AEH EU DJGLKDJ ERHISHKL QLR UHER GHSLHLSH
RBGHSD SLH SKEHRT RSKIEHB Q87O3WSL B SDKLQI WPE WEGIUQ HIHQPIG H QPGKLXK ZLQA
HQP GTHQPG Z AOIRPH PGT3Q PGHSE QAPUR HPQYPQ A XC N SLKG PZEAF RQIUH RS H
T38753QO SL KG OW7TY OQ HSL QP YOQ287 _W7 TOQR TL DSLSD YSIUYG RISWYG VQ369R4
ORA47Q3 Y94 Z Q374R R462QTQ;



%put %MLSORT2 (SORTIN=&LIST,SEQ=A,NODUP=N);
%put  %MLSORT2 (SORTIN=&LIST,SEQ=D,NODUP=N);
%put %MLSORT2 (SORTIN=&LIST,SEQ=A,NODUP=Y);
%put  %MLSORT2 (SORTIN=&LIST,SEQ=D,NODUP=Y);
*/


%MACRO MLSORT2 (SORTIN=,SEQ=A,NODUP=N,MSG=Y,LEN=8);
   %LOCAL COLL D DGT N POS PREVW SORTWK W;
   %IF &SEQ EQ A
      %THEN %LET COLL = *0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_;
      %ELSE %LET COLL = *_ZYXWVUTSRQPONMLKJIHGFEDCBA9876543210;


   %DO N=1 %TO 38; %LOCAL P&N; %END;


   %DO POS=&LEN %TO 1 %BY -1;
      %LET N = 1;
      %LET W = %SCAN(&SORTIN,1);
      %DO %WHILE (&W NE);
         %LET DGT = %INDEX (&COLL,%SUBSTR(&W*******,&POS,1));
         %LET P&DGT = &&P&DGT &W;
         %LET N = %EVAL(&N+1);
         %LET W = %SCAN(&SORTIN,&N);
      %END;
      %LET SORTIN =;
      %DO J=1 %TO 38;
         %LET SORTIN = &SORTIN &&P&J;
         %LET P&J = ;
      %END;
   %END;


   %LET N = %EVAL(&N-1);
   %LET D = 0;
   %LET PREVW =;


   %IF &NODUP NE N %THEN %DO J=1 %TO &N;
       %LET W = %SCAN(&SORTIN,&J);
       %IF &W NE &PREVW %THEN %LET SORTWK = &SORTWK &W;
       %ELSE %LET D = %EVAL(&D+1);
       %LET PREVW = &W;
   %END;




   %IF &NODUP NE N %THEN &SORTWK;
   %ELSE                 &SORTIN;
%MEND MLSORT2;


/*http://listserv.uga.edu/cgi-bin/wa?A2=ind9907C&L=sas-l&P=R1337

Dorfman
%LET LIST =
SG FJLKDSN GEWO OPITHUI GJSERO TNJEOWIJ TW9345Y TWES SDJGJSRL NWOITJN RET
POTREPOR _5TWT WPST NWP4 T924YW P9YTP9W4 NT599P DLKFGBLK SDGSGIW A AEG AEF ZG
EGH A G HA HESH AIT4Y8W3 HAW T83PTQ3Y O OYTP53YT PQYP8Y3Q SSLKGH SLIEUH AERH
DQLUEIUR SL SLSHIH4 AEK AH5WO TA AEH EU DJGLKDJ ERHISHKL QLR UHER GHSLHLSH
RBGHSD SLH SKEHRT RSKIEHB Q87O3WSL B SDKLQI WPE WEGIUQ HIHQPIG H QPGKLXK ZLQA
HQP GTHQPG Z AOIRPH PGT3Q PGHSE QAPUR HPQYPQ A XC N SLKG PZEAF RQIUH RS H
T38753QO SL KG OW7TY OQ HSL QP YOQ287 _W7 TOQR TL DSLSD YSIUYG RISWYG VQ369R4
ORA47Q3 Y94 Z Q374R R462QTQ;
%put %MLSORT3 (SORTIN=&LIST,SEQ=A,NODUP=N);
%put %MLSORT3 (SORTIN=&LIST,SEQ=D,NODUP=N);
%put %MLSORT3 (SORTIN=&LIST,SEQ=A,NODUP=Y);
%put %MLSORT3 (SORTIN=&LIST,SEQ=D,NODUP=Y);


*/


%MACRO MLSORT3 (SORTIN=,SEQ=A,NODUP=N,MSG=Y);
   %LOCAL G I INV J N T;


   %IF &SEQ EQ A %THEN %LET SEQ = G;
   %ELSE              %LET SEQ = L;


   %DO %UNTIL (&&W&N EQ);
      %LET N = %EVAL(&N+1);
      %LET W&N = %SCAN(&SORTIN,&N);
   %END;
   %LET N = %EVAL(&N-1);


   %LET G = &N;
   %DO %UNTIL (&INV AND &G=1);
      %LET INV = 1;
      %LET G  = %EVAL(&G*10/13);
      %IF &G EQ 9 OR &G EQ 10 %THEN %LET G = 11;
      %ELSE %IF &G EQ  0 %THEN %LET G =  1;


      %DO I=1 %TO %EVAL(&N-&G);
         %LET J = %EVAL(&I+&G);
         %IF &&W&I &SEQ.T &&W&J %THEN %DO;
            %LET T   = &&W&J;
            %LET W&J = &&W&I;
            %LET W&I = &T;
            %LET INV = 0;
         %END;
      %END;
   %END;


   %LET SORTIN = &W1;
   %LET T = 0;


   %IF &NODUP NE N %THEN %DO I=2 %TO &N;
      %LET J = %EVAL(&I-1);
      %IF &&W&I NE &&W&J %THEN %LET SORTIN = &SORTIN &&W&I;
      %ELSE %LET T = %EVAL(&T+1);
   %END;
   %ELSE %DO I=2 %TO &N;
      %LET SORTIN = &SORTIN &&W&I;
   %END;

   &SORTIN
%MEND MLSORT3;


/*<pre><b>
/ Program   : nodup.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry (http://www.datasavantconsulting.com/roland/)
/ Date      : 04-May-2011
/ Purpose   : Function-style macro to drop duplicates in a space-delimited list
/ SubMacros : %words
/ Notes     : 
/ Usage     : %let str=%nodup(aaa bbb aaa);
/             %put %nodup(aaa bbb aaa); 
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ list              (pos) space-delimited list of items
/ casesens=no       Case sensitive. no by default.
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  29Mar07         Put out "macro called" message plus header tidy
/ rrb  31Jul07         Header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/


%macro nodup(list,casesens=no);

  %local i j match item errflag err;
  %let err=ERR%str(OR);
  %let errflag=0;
  %if not %length(&casesens) %then %let casesens=no;
  %let casesens=%upcase(%substr(&casesens,1,1));

  %if not %index(YN,&casesens) %then %do;
    %put &err: (nodup) casesens must be set to yes or no;
    %let errflag=1;
  %end;

  %if &errflag %then %goto exit;

  %do i=1 %to %words(&list);
    %let item=%scan(&list,&i,%str( ));
    %let match=NO;
    %if &i LT %words(&list) %then %do;
      %do j=%eval(&i+1) %to %words(&list);
        %if &casesens EQ Y %then %do;
          %if "&item" EQ "%scan(&list,&j,%str( ))" %then %let match=YES;
        %end;
        %else %do;
          %if "%upcase(&item)" EQ "%upcase(%scan(&list,&j,%str( )))" %then %let match=YES;
        %end;
      %end;
    %end;
    %if &match EQ NO %then &item;
  %end;

  %goto skip;
  %exit: %put &err: (nodup) Leaving macro due to problem(s) listed;
  %skip:

%mend nodup;
  

/*<pre><b>
/ Program   : noquotes.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry (http://www.datasavantconsulting.com/roland/)
/ Date      : 04-May-2011
/ Purpose   : Function-style macro to remove all quoted strings from a macro
/             expression.
/ SubMacros : none
/ Notes     : This gets rid of all quoted strings and returns what is left.
/ Usage     : %let noquotes=%noquotes(&str);
/             %put %noquotes(%str(a e "c" e)); 
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ str               (pos) String
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  29Mar07         Put out "macro called" message plus header tidy
/ rrb  30Jul07         Header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/


%macro noquotes(str);

  %local i pos1 pos2 qtype tempstr;
  %let tempstr=&str;

  %redo:

  %let pos1=0;
  %let pos2=0;
  %let qtype=;

  %do i=1 %to %length(&tempstr);
    %if &pos1 EQ 0 %then %do;
      %if %qsubstr(&tempstr,&i,1) EQ %str(%')
       or %qsubstr(&tempstr,&i,1) EQ %str(%") %then %do;
        %let pos1=&i;
        %let qtype=%qsubstr(&tempstr,&i,1);
      %end;
    %end;
    %else %if (&pos1 GT 0) and (&pos2 EQ 0) %then %do;
      %if %qsubstr(&tempstr,&i,1) EQ %str(&qtype) %then %let pos2=&i;
    %end;
  %end; 

  %if (&pos1 GT 0) and (&pos2 GT 0) %then %do;
    %if (&pos1 GT 1) and (&pos2 LT %length(&tempstr)) %then
      %let tempstr=%qsubstr(&tempstr,1,&pos1-1)%qsubstr(&tempstr,&pos2+1);
    %else %if (&pos1 EQ 1) and (&pos2 LT %length(&tempstr)) %then
      %let tempstr=%qsubstr(&tempstr,&pos2+1);
    %if (&pos1 GT 1) and (&pos2 EQ %length(&tempstr)) %then
      %let tempstr=%qsubstr(&tempstr,1,&pos1-1);
    %else %if (&pos1 EQ 1) and (&pos2 EQ %length(&tempstr)) %then
      %let tempstr=;
    %if %length(&tempstr) %then %goto redo;
  %end;

&tempstr

%mend noquotes;

/*%num_tokens 
 Purpose: Count the number of “tokens” (variables) in a list. 
 Required arguments: 
   words – the variable list 
 Optional arguments: 
   delim – the character(s) separating each variable in the &words list [default: space] 

 Example: 
     %put  %num_tokens(a b c d e);
     %put  %num_tokens(a-b-c-d-e, delim=-);

 Credit:
    source code from Robert J. Morris, Text Utility Macros for Manipulating Lists of Variable Names
        (SUGI 30, 2005) www2.sas.com/proceedings/sugi30/029-30.pdf
    authored by Gabriel Cano;
*/

%macro num_tokens(words, delim=%str( )); 
    %local counter; 
    %* Loop through the words list, incrementing a counter for each word found. ; 
    %let counter = 1; 
    %do %while (%length(%scan(&words, &counter, &delim)) > 0); 
        %let counter = %eval(&counter + 1); 
    %end; 
    %* Our loop above pushes the counter past the number of words by 1. ; 
    %let counter = %eval(&counter - 1); 
    %* Output the count of the number of words. ; 
    &counter 
%mend num_tokens; 
/*http://listserv.uga.edu/cgi-bin/wa?A2=ind0410b&L=sas-l&F=P&S=&P=16933 Roland

%let listx=  bbb  nnnn eer rr rt  x x v  zz aaaaaa  gggg    j;

%put  %order(&listx) ;
*/


%macro order(str);
  %local swap words i list newlist scana scanb len lena lenb endpos;
  %let list=%sysfunc(compbl(%sysfunc(trim(%sysfunc(left(&str))))));
  %let words=%length(&list)-%length(%sysfunc(compress(&list,%str())))+1;
  %let len=%length(&list);
  %let swap=1;
  %do %while(&swap);
    %let swap=0;
    %do i=1 %to %eval(&words-1);
      %let scana=%scan(&list,&i,%str( ));
      %let scanb=%scan(&list,%eval(&i+1),%str( ));
      %let lena=%length(&scana);
      %let lenb=%length(&scanb);
      %if "&scana" GT "&scanb" %then %do;
        %let swap=1;
        %let newlist=;
        %let pos=%index(&list,&scana &scanb);
        %if &pos gt 1 %then %let newlist=%substr(&list,1,%eval(&pos-1));
        %let newlist=%left(&newlist &scanb &scana);
        %let endpos=%eval(&pos+&lena+&lenb);
        %if &endpos LT &len 
          %then %let newlist=%sysfunc(left(&newlist%substr(&list,%eval(&endpos+1))));
        %let list=&newlist;
      %end;
    %end;
  %end;
  &list
%mend;

/*%parallel_join 
    Purpose: Join two variable lists by connecting each variable in the first list 
             to its correspondingvariable in the second list by a text string. 
    dependence: %num_tokens

    Required arguments: 
        words1 – the first variable list 
        words2 – the second variable list 
        joinstr – the text string used to join the variable names in &words1 with the variable names in &words2 
    Optional arguments: 
        delim1 – the character(s) separating each variable in the &words1 list [default: space] 
        delim2 – the character(s) separating each variable in the &words2 list [default: space] 

    Examples: 
    %put  %parallel_join(a b c, d e f, *);                    *produces the text a*d b*e c*f ;           
    %put  %parallel_join(a#b#c, d.e.f, *, delim1=#, delim2=.);*produces the text a*d b*e c*f;

    Credit:
      source code from Robert J. Morris, Text Utility Macros for Manipulating Lists of Variable Names
        (SUGI 30, 2005) www2.sas.com/proceedings/sugi30/029-30.pdf            
*/


%macro parallel_join(words1, words2, joinstr, delim1=%str( ), delim2=%str( )); 
    %local i num_words1 num_words2 word outstr; 
    %* Verify macro arguments. ; 

    %if (%length(&words1) eq 0) %then %do; 
        %put ***ERROR(parallel_join): Required argument 'words1' is missing.; 
        %goto exit; 
    %end; 
    %if (%length(&words2) eq 0) %then %do; 
        %put ***ERROR(parallel_join): Required argument 'words2' is missing.; 
        %goto exit; 
    %end; 
        %if (%length(&joinstr) eq 0) %then %do; 
        %put ***ERROR(parallel_join): Required argument 'joinstr' is missing.; 
        %goto exit; 
    %end; 

    %* Find the number of words in each list. ; 
    %let num_words1 = %num_tokens(&words1, delim=&delim1); 
    %let num_words2 = %num_tokens(&words2, delim=&delim2); 
    %* Check the number of words. ; 
    %if (&num_words1 ne &num_words2) %then %do; 
        %put ***ERROR(parallel_join): The number of words in 'words1' and; 
        %put *** 'words2' must be equal.; 
        %goto exit; 
    %end; 
    %* Build the outstr by looping through the corresponding words and joining 
    * them by the joinstr. ; 
    %let outstr=; 
    %do i = 1 %to &num_words1; 
        %let word = %scan(&words1, &i, &delim1); 
        %let outstr = &outstr &word&joinstr%scan(&words2, &i, &delim2); 
    %end; 
    %* Output the list of joined words. ; 
    &outstr 
    %exit: 
%mend parallel_join; 
/*<pre><b>
/ Program   : prefix.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry (http://www.datasavantconsulting.com/roland/)
/ Date      : 12-Jun-2011
/ Purpose   : Function-style macro to return a list with a prefix added.
/ SubMacros : none
/ Notes     : Items in matching quotes are treated as single elements
/ Usage     : %let preflist=%prefix(C:\mylib\,fname1 "fname 2" fname3);
/             %put %prefix(C:\mylib\,fname1 "fname 2" fname3); 
/             
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ prefix            (pos) Text to prefix each item with (unquoted)
/ list              (pos) List of items to prefix (separated by spaces)
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ 
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/


%macro prefix(prefix,list);
  %local i bit;
  %let i=1;
  %let bit=%sysfunc(scanq(&list,&i,%str( )));
  %do %while(%length(&bit));
&prefix.&bit
    %let i=%eval(&i+1);
    %let bit=%sysfunc(scanq(&list,&i,%str( )));
  %end;
%mend prefix;

/*<pre><b>
/ Program      : qdequote.sas
/ Version      : 1.3
/ Author       : Roland Rashleigh-Berry (http://www.datasavantconsulting.com/roland/)
/ Date         : 16-Nov-2011
/ Purpose      : Function-style macro to remove front and end matching quotes
/                from a macro string and return the result MACRO QUOTED.
/ SubMacros    : none
/ Notes        : This is a function-style macro. The resulting expression will
/                be MACRO QUOTED so you will have to use the %unquote() function
/                if you are using the results in sas code. See usage notes.
/ Usage        : %let str=%qdequote(%qreadpipe(echo '%username%'));
/                CLASS %unquote(%qdequote('&trtvar')) ;
/                %put %qdequote(%qreadpipe(echo '%username%')); 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ N/A
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  30Jul07         Header tidy
/ rrb  19Jan08         Note added in header about macro quoting
/ rrb  31Oct08         Purpose in header updated 
/ rrb  01Jan09         Use %qtrim() instead of %quote()
/ rrb  12Oct09         Macro renamed from dequote to qdequote (v1.2)
/ rrb  04May11         Code tidy
/ rrb  16Nov11         Bug when str is "" fixed (v1.3)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/


%macro qdequote(str);
  %if (%qsubstr(&str,1,1) EQ %str(%') and %qsubstr(&str,%length(&str),1) EQ %str(%'))
  or (%qsubstr(&str,1,1) EQ %str(%") and %qsubstr(&str,%length(&str),1) EQ %str(%"))
  %then %do;
    %if %length(&str) LE 2 %then %qtrim();
    %else %qsubstr(&str,2,%length(&str)-2);
  %end;
  %else %qtrim(&str);
%mend qdequote;




/*<pre><b>
/ Program   : qreadpipe.sas
/ Version   : 2.1
/ Author    : Roland Rashleigh-Berry (http://www.datasavantconsulting.com/roland/)
/ Date      : 23-Sep-2011
/ Purpose   : Function-style macro to read the output of a system command and
/             return the result trimmed and MACRO QUOTED.
/ SubMacros : %qtrim
/ Notes     : Result will be MACRO QUOTED. Use %unquote to make the string
/             output usable in ordinary sas code.
/ Usage     : %let mvar=%qreadpipe(echo $USER);
/             %put  %qreadpipe(echo '%username%');
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ command           (pos) System command. This should not be enclosed in quotes
/                   but may be enclosed in %str(), %quote() etc..
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  13Feb07         "macro called" message added
/ rrb  22Jul07         Header tidy
/ rrb  30Jul07         Header tidy
/ rrb  31Oct08         Major redesign for v2.0
/ rrb  12Oct09         Macro renamed from readpipe to qreadpipe (v2.1)
/ rrb  04May11         Code tidy
/ rrb  23Sep11         Header tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%macro qreadpipe(command);
  %local fname fid str rc res err;
  %let err=ERR%str(OR);
  %let rc=%sysfunc(filename(fname,&command,pipe));
  %if &rc NE 0 %then %do;
    %put &err: (qreadpipe) Pipe file could not be assigned due to the following:;
    %put %sysfunc(sysmsg());
  %end;
  %else %do;
    %let fid=%sysfunc(fopen(&fname,s,80,b));
    %if &fid EQ 0 %then %do;
  %put &err: (qreadpipe) Pipe file could not be opened due to the following:;
  %put %sysfunc(sysmsg());
    %end;
    %else %do;
      %do %while(%sysfunc(fread(&fid)) EQ 0);
        %let rc=%sysfunc(fget(&fid,str,80));
        %let res=&res%superq(str);
      %end;
%qtrim(&res)
      %let rc=%sysfunc(fclose(&fid));
      %if &rc NE 0 %then %do;
  %put &err: (qreadpipe) Pipe file could not be closed due to the following:;
  %put %sysfunc(sysmsg());
      %end;
      %let rc=%sysfunc(filename(fname));
      %if &rc NE 0 %then %do;
  %put &err: (qreadpipe) Pipe file could not be deassigned due to the following:;
  %put %sysfunc(sysmsg());
      %end;
    %end;
  %end;
%mend qreadpipe;


%macro qt(
       l=           /* value list */
     , lv=          /* external variable override for value list */
     , lsep=%str( ) /* separator between values */
     , qt=%str(%")  /* type of quote mark */
     , osep=%str( ) /* separtor for returned list */
     ) ;

 /* List of items separated by &lsep
     Return items in list quoted with &qt, and separated with &osep
     if lsep is not %STR( ) then there can be only one separator between items.
     Note: leading and trailing spaces are stripped from list when LSEP is %STR( ).
     LV provides override to specify external variable name instead list.
     If the LV option is used then L and QT_: should be avoided for variable names.

examples:
    %put %qt(l=a b c,osep=%str(,));

Credit:
    source code from Ian Whitlock, Names, Names, Names - Make Me a List
               (SGF 2007)   http://www2.sas.com/proceedings/forum2007/052-2007.pdf
               (SESUG 2008) http://analytics.ncsu.edu/sesug/2008/SBC-128.pdf

 */

 %local qt_list ;
 %if %length(&lv) = 0 %then
 %let lv = l ;
 %if %superq(lsep) = %str( ) and %length(&lsep)=1 %then
 %do ;
     %let qt_list = %qsysfunc(strip(%superq(&lv))) ;
     %if %length(&qt_list) > 0 %then
     %let qt_list = %qsysfunc(compbl(&qt_list)) ;
 %end ;
 %else
     %let qt_list = %superq(&lv) ;
 %if %length(&qt_list) > 0 %then
     %do ;
     %unquote(&qt%qsysfunc(tranwrd( &qt_list
     , &lsep
     , &qt&osep&qt
     )
     )&qt
     )
 %end ;
%mend qt ;
/*<pre><b>
/ Program   : quotecnt.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry (http://www.datasavantconsulting.com/roland/)
/ Date      : 04-May-2011
/ Purpose   : Function-style macro to count quoted strings in a macro expression
/ SubMacros : none
/ Notes     : This returns the number of quoted strings.
/ Usage     : %let count=%quotecnt(&str);
/             %put %quotecnt(%str(a b "cc"));  
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ str               (pos) String
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  29Mar07         Put out "macro called" message and header tidy
/ rrb  30Jul07         Header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%macro quotecnt(str);

  %local i pos1 pos2 qtype tempstr count;
  %let tempstr=&str;
  %let count=0;

  %redo:

  %let pos1=0;
  %let pos2=0;
  %let qtype=;

  %do i=1 %to %length(&tempstr);
    %if &pos1 EQ 0 %then %do;
      %if %qsubstr(&tempstr,&i,1) EQ %str(%')
       or %qsubstr(&tempstr,&i,1) EQ %str(%") %then %do;
        %let pos1=&i;
        %let qtype=%qsubstr(&tempstr,&i,1);
      %end;
    %end;
    %else %if (&pos1 GT 0) and (&pos2 EQ 0) %then %do;
      %if %qsubstr(&tempstr,&i,1) EQ %str(&qtype) %then %let pos2=&i;
    %end;
  %end; 

  %if (&pos1 GT 0) and (&pos2 GT 0) %then %do;
    %let count=%eval(&count + 1);
    %if (&pos1 GT 1) and (&pos2 LT %length(&tempstr)) %then
      %let tempstr=%qsubstr(&tempstr,1,&pos1-1)%qsubstr(&tempstr,&pos2+1);
    %else %if (&pos1 EQ 1) and (&pos2 LT %length(&tempstr)) %then
      %let tempstr=%qsubstr(&tempstr,&pos2+1);
    %if (&pos1 GT 1) and (&pos2 EQ %length(&tempstr)) %then
      %let tempstr=%qsubstr(&tempstr,1,&pos1-1);
    %else %if (&pos1 EQ 1) and (&pos2 EQ %length(&tempstr)) %then
      %let tempstr=;
    %if %length(&tempstr) %then %goto redo;
  %end;

&count

%mend quotecnt;  
/*<pre><b>
/ Program   : quotelst.sas
/ Version   : 1.1
/ Author    : Roland Rashleigh-Berry (http://www.datasavantconsulting.com/roland/)
/ Date      : 04-May-2011
/ Purpose   : Function-style macro to quote the elements of a list
/ SubMacros : none
/ Notes     : DO NOT COPY AND PASTE THIS FROM THIS BROWSER WINDOW. YOU MUST USE
/             THE "VIEW" PULL-DOWN WINDOW AND USE "SOURCE". This is because the
/             browser will change some of the characters in this file to quotes.
/
/             This is useful to turn a list into a quoted list so that you can
/             use the in() function on it in a data step. Also, if you search for
/             a quoted string among a list of quoted strings then you can avoid
/             matching on a subset of a single element. Note that you can change
/             not only the quote mark but the delimiter as well so you can use
/             this macro for other purposes like putting commas between variable
/             names etc. It is assumed that the elements of the list are
/             delimited by spaces.
/ Usage     : %put %quotelst(a b c d);
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ str               String to quote elements of (pos)
/ quote=%str(%")    Quote character to use (defaults to double quotation mark)
/ delim=%str( )     Delimiter character to use (defaults to a space)
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  13Feb07         "macro called" message added
/ rrb  30Jul07         Header tidy
/ rrb  21May08         Use of %scan replaced by %qscan
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/


%macro quotelst(str,quote=%str(%"),delim=%str( ));
  %local i quotelst;
  %let i=1;
  %do %while(%length(%qscan(&str,&i,%str( ))) GT 0);
    %if %length(&quotelst) EQ 0 %then %let quotelst=&quote.%qscan(&str,&i,%str( ))&quote;
    %else %let quotelst=&quotelst.&quote.%qscan(&str,&i,%str( ))&quote;
    %let i=%eval(&i + 1);
    %if %length(%qscan(&str,&i,%str( ))) GT 0 %then %let quotelst=&quotelst.&delim;
  %end;
%unquote(&quotelst)
%mend quotelst;
/*<pre><b>
/ Program   : quotescan.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry (http://www.datasavantconsulting.com/roland/)
/ Date      : 04-May-2011
/ Purpose   : Function-style macro to scan for a quoted string in a macro
/             expression.
/ SubMacros : none
/ Notes     : The quoted string will still have its quote marks around it.
/             A null string will be returned if there is nothing quoted.
/             Note that any string returned will be macro-quoted so you should
/             put it inside %unquote() if using the output in normal sas code.
/ Usage     : %let scan=%quotescan(&str,2);
/            %put %quotescan(%str( a b "ee" "r" e ),2);
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ str               (pos) String
/ pos               (pos) Position
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  29Mar07         Put out "macro called" message plus header tidy
/ rrb  28May07         Header tidy
/ rrb  30Jul07         Header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%macro quotescan(str,pos);

  %local i pos1 pos2 qtype tempstr count qstr;
  %let tempstr=&str;
  %let count=0;
  %if not %length(&pos) %then %let pos=1;
  %redo:

  %let pos1=0;
  %let pos2=0;
  %let qtype=;

  %do i=1 %to %length(&tempstr);
    %if &pos1 EQ 0 %then %do;
      %if %qsubstr(&tempstr,&i,1) EQ %str(%')
       or %qsubstr(&tempstr,&i,1) EQ %str(%") %then %do;
        %let pos1=&i;
        %let qtype=%qsubstr(&tempstr,&i,1);
      %end;
    %end;
    %else %if (&pos1 GT 0) and (&pos2 EQ 0) %then %do;
      %if %qsubstr(&tempstr,&i,1) EQ %str(&qtype) %then %let pos2=&i;
    %end;
  %end; 

  %if (&pos1 GT 0) and (&pos2 GT 0) %then %do;
    %let count=%eval(&count + 1);
    %let qstr=%qsubstr(&tempstr,&pos1,%eval(&pos2-&pos1+1));
    %if (&pos1 GT 1) and (&pos2 LT %length(&tempstr)) %then
      %let tempstr=%qsubstr(&tempstr,1,&pos1-1)%qsubstr(&tempstr,&pos2+1);
    %else %if (&pos1 EQ 1) and (&pos2 LT %length(&tempstr)) %then
      %let tempstr=%qsubstr(&tempstr,&pos2+1);
    %if (&pos1 GT 1) and (&pos2 EQ %length(&tempstr)) %then
      %let tempstr=%qsubstr(&tempstr,1,&pos1-1);
    %else %if (&pos1 EQ 1) and (&pos2 EQ %length(&tempstr)) %then
      %let tempstr=;
    %if (&count LT &pos) and %length(&tempstr) %then %goto redo;
  %end;

  %if &count EQ &pos %then &qstr;

%mend quotescan;  
%macro range (
       to  =        /* end integer value */
     , from=1       /* starting integer value */
     , step=1       /* increment integer */
     , osep=%str( ) /* separator between integers */
     , opre=%str()  /* prefix for sequence of integers*/
     , osuf=%str()  /* suffix for sequence of integers*/
     ) ;

/*
return sequence of integers like 1 2 3 or
    strings ended with sequences of integers like data1 data2 data3
    starting at &FROM going to &TO in steps of &step

examples:
   %put %range(to=10);
   %put %range(to=10, opre=%str(data));
   %put %range(from=2,to=10,step=3,osep=%str(,));
   %put %range(from=2,to=10,step=3,osep=%str(,),osuf=%str(a));

   data a1;
	 a1=1;
   run;

   data a2;
	 a2=2;
   run;

   data a3;
	 a3=3;
   run;

	 data combine0;
	 	set a1-a3;
	run;

   %macro doit;
	   %let n=3;
	   data combine1;
		 set %do i=1 %to &n; a&i %end; ;
	   run;
   %mend;
   %doit
  
   %macro doit;
	   data combine2;
		 set %range(to=3,opre=%str(a));
	   run;
   %mend;
   %doit

	%macro doit;
		proc sql;                  
		  create table combine3 as    
		    select *      
		    from %range(to=3,osep=%str(,),opre=%str(a));
		quit;  
		%mend;
    %doit


	 %macro _list(n,pre=ds);
    %if &n=1 %then &pre.1;
     %else %_list(%eval(&n-1)),&pre.&n;
%mend _list;

%put %_list(10); 


Credit:
    source code from Ian Whitlock, Names, Names, Names - Make Me a List
               (SGF 2007)   http://www2.sas.com/proceedings/forum2007/052-2007.pdf
               (SESUG 2008) http://analytics.ncsu.edu/sesug/2008/SBC-128.pdf
    This snippet used a more efficient style from Chang Chung(http://changchung.com)
    Jiangtang Hu (2013, http://www.jiangtanghu.com):
        1)added two parameters (prefix/suffix) so it works more than generating sequence of integers
*/

 %local rg_i ;
 %do rg_i = &from %to &to %by &step ;
     %if &rg_i = &from %then
     %do;&opre.&rg_i.&osuf%end ;
     %else
     %do;&osep.&opre.&rg_i.&osuf%end ;
 %end ;
%mend range ;

/*
examples:
%put %range_non_int(start = 1 , end = 5 , by = .25 ) ;

Source: http://support.sas.com/kb/37/536.html
Modified by Jiangtang Hu (2013, http://www.jiangtanghu.com)

*/

%macro range_non_int( start= , end= , by= ) ;
    %local list;

    %do i = 1 %to %eval(%sysfunc( ceil( %sysevalf( ( &end - &start ) / &by ) ) ) +1) ;
       %let value=%sysevalf( ( &start - &by ) + ( &by * &i ) ) ;
       %if &value <=&end %then %do;
           %let list=&list. &value;
       %end;
    %end ;
    &list
%mend range_non_int ;
/*<pre><b>
/ Program   : remove.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry (http://www.datasavantconsulting.com/roland/)
/ Date      : 04-May-2011
/ Purpose   : Function-style macro to remove all occurrences of the target
/             string(s) from another string.
/ SubMacros : none
/ Notes     : none
/ Usage     : %let string2=%remove(&string1,XXX,yyy,YYY);
/             %put %remove(aaa xxx yyy yyee,XXX,yyy,YYY);
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ string            (pos - unquoted) String to remove target from
/ target1-30        (pos - unquoted) Target string(s) to remove
/ casesens=no       Whether the search for the target(s) is case sensitive
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  13Feb07         "macro called" message added
/ rrb  30Jul07         Header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%macro remove(string,
              target1,
              target2,
              target3,
              target4,
              target5,
              target6,
              target7,
              target8,
              target9,
              target10,
              target11,
              target12,
              target13,
              target14,
              target15,
              target16,
              target17,
              target18,
              target19,
              target20,
              target21,
              target22,
              target23,
              target24,
              target25,
              target26,
              target27,
              target28,
              target29,
              target30,
           casesens=no
              );

  %local i result index targlen beyond newstr;

  %if not %length(&casesens) %then %let casesens=no;
  %let casesens=%upcase(%substr(&casesens,1,1));

  %let result=&string;

  %do i=1 %to 30;
    %let targlen=%length(&&target&i);
    %if &targlen %then %do;
      %if "&casesens" EQ "Y" %then %let index=%index(&result,&&target&i);
      %else %let index=%index(%qupcase(&result),%qupcase(&&target&i));
      %do %while(&index GT 0);
        %if &index GT 1 %then %let newstr=%qsubstr(&result,1,%eval(&index-1));
        %else %let newstr=;
        %let beyond=%eval(&index+&targlen);
        %if &beyond LE %length(&result) %then %let newstr=&newstr%qsubstr(&result,&beyond);
        %let result=&newstr;
        %if "&casesens" EQ "Y" %then %let index=%index(&result,&&target&i);
        %else %let index=%index(%qupcase(&result),%qupcase(&&target&i));
      %end;
    %end;
  %end;

&result

%mend remove;
/*<pre><b>
/ Program   : removew.sas
/ Version   : 1.1
/ Author    : Roland Rashleigh-Berry (http://www.datasavantconsulting.com/roland/)
/ Date      : 05-Dec-2012
/ Purpose   : Function-style macro to remove all occurrences of the target
/             word(s) from a source list of words.
/ SubMacros : %words
/ Notes     : For a word to be removed, the whole word must match. This macro
/             will not remove substrings in the sense that "low" will not be
/             removed from the end of the word "yellow". Multiple occurences of
/             a word will be removed. This macro will only work correctly for
/             lists of space-delimited words containing no special characters
/             that need quoting. You should avoid combinations of a string with
/             many words and many target words such that their product is very
/             high (e.g. 100 x 100 = 10000) as this code will run slow and use
/             a lot of processor power. Data step solutions or SQL solutions are
/             better for those cases. Final result returned will have leading
/             and trailing spaces removed and multiple adjacent blanks replaced
/             by single blanks.
/ Usage     : %let colors2=%removew(&rainbow,green yellow);
/             %put %removew(green yellow red,green yellow);
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ string            (pos) Unquoted space-delimited source list of words
/ targetwords       (pos) Unquoted space-delimited target word(s) to remove
/ casesens=no       Whether the search for the target word(s) is case sensitive
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  26Jan08         compbl bug fixed
/ rrb  04May11         Code tidy
/ rrb  05Dec12         Usage notes macro call coreected
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/

%macro removew(string,
          targetwords,
             casesens=no
              );

  %local i j result match twords swords tword sword;

  %if not %length(&casesens) %then %let casesens=no;
  %let casesens=%upcase(%substr(&casesens,1,1));

  %let twords=%words(&targetwords);
  %let swords=%words(&string);

  %let result=;

  %do i=1 %to &swords;
    %let match=0;
    %let sword=%scan(&string,&i,%str( ));
    %do j=1 %to &twords;
      %let tword=%scan(&targetwords,&j,%str( ));
      %if "&casesens" EQ "Y" %then %do;
        %if "&tword" EQ "&sword" %then %do;
          %let match=1;
          %let j=&twords;
        %end;
      %end;
      %else %do;
        %if "%upcase(&tword)" EQ "%upcase(&sword)" %then %do;
          %let match=1;
          %let j=&twords;
        %end;
      %end;
    %end;
    %if not &match %then %let result=&result &sword;
  %end;

  %if %length(&result) %then %let result=%sysfunc(compbl(&result));

&result

%mend removew;
/*%rename_string 
    Purpose: Create a list suitable for the rename statement where the variables in a list 
                are renamed so that they have a common text string as a prefix or suffix.
    dependence: %num_tokens, %parallel_join, %add_string
 

    Required arguments: 
        words – the variable list containing the original names 
        str – the text string to add to each renamed variable 

    Optional arguments: 
        location – whether to add the text string as a prefix or suffix [prefix|suffix, default: suffix] 
        delim – the character(s) separating each variable in the &words list [default: space] 

    Examples: 
    %put  %rename_string(a b c, _1);
                produces the text a=a_1 b=b_1 c=c_1
    %put %rename_string(a b c, r_, location=prefix);
                produces the text a=r_a b=r_b c=r_c
    %put  %rename_string(a|b|c, _1, delim=|);
                produces the text a=a_1 b=b_1 c=c_1
    Credit:
        source code from Robert J. Morris, Text Utility Macros for Manipulating Lists of Variable Names
          (SUGI 30, 2005) www2.sas.com/proceedings/sugi30/029-30.pdf   
*/


%macro rename_string(words, str, delim=%str( ), location=suffix); 
    %* Verify macro arguments. ; 
    %if (%length(&words) eq 0) %then %do; 
        %put ***ERROR(rename_string): Required argument 'words' is missing.; 
        %goto exit; 
    %end; 

    %if (%length(&str) eq 0) %then %do; 
        %put ***ERROR(rename_string): Required argument 'str' is missing.; 
        %goto exit; 
    %end; 
    %if (%upcase(&location) ne SUFFIX and %upcase(&location) ne PREFIX) %then %do; 
        %put ***ERROR(rename_string): Optional argument 'location' must be; 
        %put *** set to SUFFIX or PREFIX.; 
        %goto exit; 
    %end; 

    %* Since rename_string is just a special case of parallel_join, 
    * simply pass the appropriate arguments on to that macro. ; 
    %parallel_join( 
    &words, 
    %add_string(&words, &str, delim=&delim, location=&location), 
    =, 
    delim1 = &delim, 
    delim2 = &delim 
    ) 
    %exit: 
%mend rename_string; 
%macro replace(
       l=           /* value list */
     , lv=          /* external variable override for value list */
     , lsep=%str( ) /* separator between values */
     , code=        /* block of code containing symbolic variable */
     , key=#        /* symbolic variable to replace (#abc# etc.) */
     , osep=%str( ) /* separator between new elements */
                    /* may be %str(;) when code is statement */
                    /* if so remember to add closing semicolon */
     ) ;

 /* for elt in the list replace key in code
     LV provides override to specify external variable name instead of list.
     If the LV option is used then L and RG_: should be avoided for variable names.

examples:
    %macro rename ( list, pref=__ ) ;
         %* make a rename list from &LIST *;
         %replace ( l=&list, code = # = &pref# )
    %mend rename ;
    %put %rename ( x y z, pref=__ );

     %macro char2num ( list , pref = __ ) ;
     %* make list of char to num assignments *;
     %replace ( l=&list
        , code= %str(# = input(&pref#,best32.);)
      )
    %mend char2num ;
    %put %char2num(x y z);

Credit:
    source code from Ian Whitlock, Names, Names, Names - Make Me a List
               (SGF 2007)   http://www2.sas.com/proceedings/forum2007/052-2007.pdf
               (SESUG 2008) http://analytics.ncsu.edu/sesug/2008/SBC-128.pdf
 */

 %local rg_i rg_w rg_list ;
 %if %length(&lv) = 0 %then
 %let lv = l ;
 %if %length(%superq(&lv)) = 0 /*or %index(%superq(code),&key) = 0*/ %then
 %do ;
     %let rg_list = %superq(code) ;
     %goto mexit ;
 %end ;
 %do rg_i = 1 %to &sysmaxlong ;
     %let rg_w = %qscan(%superq(&lv),&rg_i,&lsep) ;
     %if %length(&rg_w) = 0 %then %goto mexit ;
     %if &rg_i = 1 %then
     %let rg_list = %sysfunc(tranwrd(%superq(code),&key,&rg_w)) ;
     %else
     %let rg_list =
     &rg_list&osep%sysfunc(tranwrd(%superq(code),&key,&rg_w)) ;
 %end ;
 %mexit:

 %unquote(&rg_list)
%mend replace ;
/*
Purpose: Reverse a macro variable's value.
Notes: For versions before v6.12. Otherwise use 
            %sysfunc(reverse(&<macro-variable>))

example:
    %put %reverse(gfee);



Credit: Richard A. DeVenezia
    http://www.devenezia.com/downloads/sas/macros/index.php?m=reverse

*/

%macro reverse (string);
  %local i rstring;
  %let rstring=;
  %let string=%quote(&string);
  %do i=%length(&string) %to 1 %by -1;%quote(%substr(&string,&i,1))%end;
%mend;


/*
Purpose: Emit a list of items separated by some delimiter

example:
    %put %seplist (a b c);
    %put %seplist (a b c, dlm=+);
    %put %seplist (a|b|c, indlm=|, dlm=%str( ));
    %put %seplist (a b c, prefix=ORACLE., nest=QQ);
    %put %seplist (a$b$c, indlm=$, suffix=@mail.com, dlm=%str( ));
    %put %seplist (a$b$c, indlm=$, prefix=antispam_, suffix=@mail.com, dlm=%str( ));
    %put %seplist (a b c, dlm=||, nest=Q);
    %put %seplist (a b c, nest=C);
    %put %seplist (a b c, nest=P);
    %put %seplist (a b c, nest=B);
    %put %seplist (a xyz b xyz c, indlm=xyz, dlm=%str( or ), prefix=%str( not ));



Credit: Richard A. DeVenezia
    http://www.devenezia.com/downloads/sas/macros/index.php?m=seplist
*/



%macro seplist (

    items
  , indlm = %str( )
  , dlm   = %str(,)
  , prefix=
  , nest=
  , suffix=

  );

%* Richard A. DeVenezia - 990902;
%*
%* emit a list of words separated by a delimiter
%*
%* items  - list of items, separated by indlm
%* indlm  - string that delimits each item of items
%*   dlm  - string that delimits list of items emitted
%* prefix - string to place before each item
%* nest   - Q (single quote ''),
%*          QQ (double quotes ""),
%*          P (parenthesis ()),
%*          C (curly braces {}),
%*          B (brackets [])
%* suffix - string to place after each item
%*
%* Note: nest is a convenience, and could be accomplished using
%*       prefix and suffix
%*;

  %local item n emit;

  %let emit=;

  %let nest = %upcase (&nest);

  %if (&nest = Q) %then %do;
    %let prefix = &prefix.%str(%');
    %let suffix = %str(%')&suffix;
  %end;
  %else
  %if (&nest = QQ) %then %do;
    %let prefix = &prefix.%str(%");
    %let suffix = %str(%")&suffix;
  %end;
  %else
  %if (&nest = P) %then %do;
    %let prefix = &prefix.%str(%();
    %let suffix = %str(%))&suffix;
  %end;
  %else
  %if (&nest = C) %then %do;
    %let prefix = &prefix.%str({);
    %let suffix = %str(})&suffix;
  %end;
  %else
  %if (&nest = B) %then %do;
    %let prefix = &prefix.%str([);
    %let suffix = %str(])&suffix;
  %end;

  %let n = 1;
  %let item = %qscan (&items, &n, %quote(&indlm));

  %do %while (%superq(item) ne );

    %if (&n = 1)
      %then %let emit = &prefix.&item.&suffix;
      %else %let emit = &emit.&dlm.&prefix.&item.&suffix;

    %let n = %eval (&n+1);
    %let item = %qscan (&items, &n, %quote(&indlm));
  %end;

  &emit

%mend;

%macro slice(
    L,            /*list*/
    i,            /*index*/
    sep_L=%str( ),/*separator for list*/
    sep_i=%str( ) /*separator for index*/
    );

    /*
    return a sub-list sliced by an index

    examples(all produce a c d):
       %put %slice(a b c d,1 3  4);                                   
       %put %slice(%str(a, b, c, d),1 3  4,sep_L=%str(,));
       %put %slice(%str(a, b, c, d),%str(1, 3, 4),sep_L=%str(,),sep_i=%str(,)); 

    Credit:
        Jiangtang Hu (2013-03-31, http://www.jiangtanghu.com):
    */

    %let VarList = ;
    %let count=%sysfunc(countw(&i,&sep_i));

    %do j = 1 %to &count;
      %let index=%qscan(&i,&j,&sep_i);
      %let VarList = &VarList.%str( )%qscan(&L,&index,&sep_L);
    %end;

    &VarList
%mend slice;

/*http://listserv.uga.edu/cgi-bin/wa?A2=ind0410b&L=sas-l&F=P&S=&P=25822

%sortc

%put ***%sorted(list=


SG FJLKDSN GEWO OPITHUI GJSERO TNJEOWIJ TW9345Y TWES SDJGJSRL NWOITJN RET
POTREPOR _5TWT WPST NWP4 T924YW P9YTP9W4 NT599P DLKFGBLK SDGSGIW A AEG AEF
ZG
EGH A G HA HESH AIT4Y8W3 HAW T83PTQ3Y O OYTP53YT PQYP8Y3Q SSLKGH SLIEUH
AERH
DQLUEIUR SL SLSHIH4 AEK AH5WO TA AEH EU DJGLKDJ ERHISHKL QLR UHER GHSLHLSH
RBGHSD SLH SKEHRT RSKIEHB Q87O3WSL B SDKLQI WPE WEGIUQ HIHQPIG H QPGKLXK
ZLQA
HQP GTHQPG Z AOIRPH PGT3Q PGHSE QAPUR HPQYPQ A XC N SLKG PZEAF RQIUH RS H
T38753QO SL KG OW7TY OQ HSL QP YOQ287 _W7 TOQR TL DSLSD YSIUYG RISWYG
VQ369R4
ORA47Q3 Y94 Z Q374R R462QTQ
)***;



*/

%macro sorted(list=, maxItemLen=100);

  %local i item mvars;

  %do %while (1);
    %let i = %eval(&i.+1);
    %let item = %qscan(%superq(list),&i.);
    %let len  = %length(%superq(item));
    %if &len.=0 %then %goto out;
    %local SORTED_&i.;
    %let SORTED_&i. = &item.%qsysfunc(repeat(%str( ), &maxItemLen.-&len.-1));
    %if &i.=1 %then
      %let mvars = SORTED_1;
    %else
      %let mvars = &mvars., SORTED_&i.;
  %end;

  %out:
  %syscall sortc(&mvars.);

  %local r;
  %do i = 1 %to %eval(&i.-1);
    %let r = &r. &&SORTED_&i..;
  %end;

  %*;&r.

%mend;

/*<pre><b>
/ Program   : splitmac.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry (http://www.datasavantconsulting.com/roland/)
/ Date      : 08-May-2011
/ Purpose   : Function-style macro to insert split characters in a macro string
/ SubMacros : none
/ Notes     : This is the sister macro to %splitmac except it works on macro
/             values instead of SAS variables. It is a function-style macro.
/
/             A split character will normally be placed in a blank space. If
/             there is no suitable space then it will be inserted after a hyphen.
/             But if there is no suitable space and no hyphen then it will be
/             inserted at the end. 
/
/             This macro will only look back the floor of half the column width
/             to find a place to insert the split character.
/
/             If the input string has one or more equals signs in it then
/             enclose the string in %str(). If it has one or more commas in it
/             then enclose it in %quote().
/
/ Usage     : %let str=The quick brown fox jumped over the lazy dog;
/             %let splitstr=%splitmac(&str,10);
/             %put %splitmac(The quick brown fox jumped over the lazy dog,10);
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ str               (pos) Macro string to split.
/ cols              (pos) Maximum number of columns allowed.
/ split=*           Split character. Must be a single character, unquoted.
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  13Feb07         "macro called" message added
/ rrb  30Jul07         Header tidy
/ rrb  08May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/


%macro splitmac(str,cols,split=*);

  %local errflag err _cols tempstr res;
  %let err=ERR%str(OR);
  %let errflag=0;

  %if not %length(&str) %then %do;
    %let errflag=1;
    %put &err: (splitmac) No string supplied as first positional parameter;
  %end;

  %if not %length(&cols) %then %do;
    %let errflag=1;
    %put &err: (splitmac) No column width supplied as second positional parameter;
  %end;
  %else %if %sysfunc(verify(&cols,1234567890)) %then %do;
    %let errflag=1;
    %put &err: (splitmac) Cols parameter "&cols" not a valid number of columns;
  %end;

  %if not %length(&split) %then %let split=*;

  %if %length(&split) GT 1 %then %do;
    %let errflag=1;
    %put &err: (splitmac) Split character &split is not a single unquoted character;
  %end;

  %if &errflag %then %goto exit;

  %let tempstr=&str;

  %do %while(%length(&tempstr) GT &cols);
    %do _cols=(&cols+1) %to %eval(&cols/2) %by -1;
      %if "%qsubstr(%quote(&tempstr),&_cols,1)" EQ " " %then %do;
        %let res=&res%qsubstr(%quote(&tempstr),1,%eval(&_cols - 1))&split;
        %let tempstr=%qsubstr(%quote(&tempstr),%eval(&_cols+1));
        %let _cols=1;
      %end;
    %end;
    %*- if space character not found look for a hyphen -;
    %if &_cols GT 1 %then %do;
      %do _cols=&cols %to %eval(&cols/2) %by -1;
        %if "%qsubstr(%quote(&tempstr),&_cols,1)" EQ "-" %then %do;
          %let res=&res%qsubstr(%quote(&tempstr),1,&_cols)&split;
          %let tempstr=%qsubstr(%quote(&tempstr),%eval(&_cols+1));
          %let _cols=1;
        %end;
      %end;
    %end;
    %*- if no hyphen found then split at end -;
    %if &_cols GT 1 %then %do;
      %let res=&res%qsubstr(%quote(&tempstr),1,&cols)&split;
      %let tempstr=%qsubstr(%quote(&tempstr),&cols+1);
    %end;
  %end;

&res&tempstr

  %goto skip;
  %exit: %put &err: (splitmac) Leaving macro due to problem(s) listed;
  %skip:

%mend splitmac;

/*<pre><b>
/ Program   : suffix.sas
/ Version   : 1.0
/ Author    : Roland Rashleigh-Berry (http://www.datasavantconsulting.com/roland/)
/ Date      : 12-Jun-2011
/ Purpose   : Function-style macro to return a list with a suffix added.
/ SubMacros : none
/ Notes     : Items in matching quotes are treated as single elements
/ Usage     : %let sufflist=%suffix(.sas,fname1 "fname 2" fname3);
/             %put %suffix(.sas,fname1 "fname 2" fname3); 
/             
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ suffix            (pos) Text to suffix each item with (unquoted)
/ list              (pos) List of items to suffix (separated by spaces)
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ 
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/


%macro suffix(suffix,list);
  %local i bit;
  %let i=1;
  %let bit=%sysfunc(scanq(&list,&i,%str( )));
  %do %while(%length(&bit));
&bit.&suffix
    %let i=%eval(&i+1);
    %let bit=%sysfunc(scanq(&list,&i,%str( )));
  %end;
%mend suffix;

/*%suffix_counter 
    Purpose: Create a list of variable names formed by adding a numeric counter suffix to a base name. 

    Required arguments: 
        base – the text that should be the base of the variable names 
        end – the last number in the counter 

    Optional arguments: 
        start – the first number inthe counter [default: 1] 
        zpad – the number of digits to which the counter should be padded. Use zpad=0 for no padding. [default: 0] 

    Examples: 
        %put  %suffix_counter(v, 4);
                    *produces the text v1 v2 v3 v4;
        %put %suffix_counter(v, 14, start=10);
                    *produces the text v10 v11 v12 v13 v14;
        %put  %suffix_counter(v, 4, zpad=2);
                    *produces the text v01 v02 v03 v04;

    Credit:
        source code from Robert J. Morris, Text Utility Macros for Manipulating Lists of Variable Names
          (SUGI 30, 2005) www2.sas.com/proceedings/sugi30/029-30.pdf  
*/


%macro suffix_counter(base, end, start=1, zpad=0); 
%local outstr i counter; 

%* Verify macro arguments. ; 
%if (%length(&base) eq 0) %then %do; 
    %put ***ERROR(suffix_counter): Required argument 'base' is missing.; 
    %goto exit; 
%end; 
%if (%length(&end) eq 0) %then %do; 
    %put ***ERROR(suffix_counter): Required argument 'end' is missing.; 
    %goto exit; 
%end; 
%if (&end < &start) %then %do; 
    %put ***ERROR(suffix_counter): The 'end' argument must not be less; 
    %put *** than the 'start' argument.; 
    %goto exit; 
%end; 

%* Construct the outstr by looping from &start to &end, adding the counter 
* value to &base in each iteration. To handle the zero-padding, use the 
* putn function to format the counter variable with the Z. format. ; 
%let outstr=; 
%do i=&start %to &end; 
    %if (&zpad > 0) %then %do; 
        %let counter = %sysfunc(putn(&i, z&zpad..)); 
    %end; 
    %else %do; 
        %let counter = &i; 
    %end; 
    %let outstr=&outstr &base&counter; 
%end; 

%* Output the new list. ; 
&outstr 
%exit: 
%mend suffix_counter; 
%macro uqt(
       l=           /* value list */
     , lv=          /* external variable override for value list */
     , lsep=%str( ) /* separator between values */
     , qt=%str(%")  /* type of quote mark */
     ) ;

 /* L (or &LV) is list of quoted items separated by LSEP

 return unquoted list of items separated by space
 LV provides override to specify external variable name instead list.
 If the LV option is used then L and UQT_: should be avoided for variable names.

examples:
    %put %Uqt(l="a" "b" "c");

Credit:
    source code from Ian Whitlock, Names, Names, Names - Make Me a List
               (SGF 2007)   http://www2.sas.com/proceedings/forum2007/052-2007.pdf
               (SESUG 2008) http://analytics.ncsu.edu/sesug/2008/SBC-128.pdf
 */

 %if %length(&lv) = 0 %then
 %let lv = l ;
 %if %length(%superq(&lv)) > 0 %then
 %do ;
     %sysfunc(compbl(%sysfunc(translate(%superq(&lv),%str( ),&qt&lsep))))
 %end ;
%mend uqt ;
/*<pre><b>
/ Program   : windex.sas
/ Version   : 1.1
/ Author    : Roland Rashleigh-Berry (http://www.datasavantconsulting.com/roland/)
/ Date      : 04-May-2011
/ Purpose   : Function-style macro to return the word count position in a string
/ SubMacros : %words
/ Notes     : none
/ Usage     : %let windex=%windex(string,target);
/             %put %windex(Word worde,worde); 
/ 
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ str               String (pos) UNQUOTED
/ target            Target string (pos) UNQUOTED
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  13Feb07         "macro called" message added
/ rrb  10May07         Break loop if match is found (v1.1)
/ rrb  30Jul07         Header tidy
/ rrb  04May11         Code tidy
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/


%macro windex(str,target);
  %local i res words;
  %let res=0;
  %let words=%words(&str);
  %do i=1 %to &words;
    %if "%scan(&str,&i,%str( ))" EQ "&target" %then %do;
      %let res=&i;
      %let i=&words;
    %end;
  %end;
&res
%mend windex;
/*<pre><b>
/ Program   : words.sas
/ Version   : 3.2
/ Author    : Roland Rashleigh-Berry (http://www.datasavantconsulting.com/roland/)
/ Date      : 09-Jan-2013
/ Purpose   : Function-style macro to return the number of words in a string
/ SubMacros : none
/ Notes     : You can change the delimiter to other than a space if required.
/ Usage     : %put %words(a b c d e);
/===============================================================================
/ PARAMETERS:
/-------name------- -------------------------description------------------------
/ str               String (pos) UNQUOTED
/ delim=%str( )     Delimeter (defaults to a space)
/===============================================================================
/ AMENDMENT HISTORY:
/ init --date-- mod-id ----------------------description------------------------
/ rrb  13Feb07         "macro called" message added
/ rrb  30Jul07         Header tidy
/ rrb  26Sep08         "countw" used for sas version 9 onwards for v2.0
/ rrb  01Sep09         Use of countw() function discontinued (v3.0)
/ rrb  04May11         Code tidy
/ rrb  02Jan13         Use of %qscan dropped (v3.1)
/ rrb  09Jan13         Use of %qscan reinstated (v3.2)
/===============================================================================
/ This is public domain software. No guarantee as to suitability or accuracy is
/ given or implied. User uses this code entirely at their own risk.
/=============================================================================*/


%macro words(str,delim=%str( ));
  %local i;
  %let i=1;
  %do %while(%length(%qscan(&str,&i,&delim)) GT 0);
    %let i=%eval(&i + 1);
  %end;
%eval(&i - 1)
%mend words;
%macro xprod(
     l1  =        /* first list */
   , lv1 =        /* external variable override for first list */
   , sep1=%str( ) /* separator between elements of first list */
   , l2  =        /* second list */
   , lv2 =        /* external variable override for second list */
   , sep2=%str( ) /* separator between elements of second list */
   , osep=%str( ) /* separator between elements of new list */
 );

 /* %xprod ( l1= a b , l2= c d ) produces ac ad bc bd

examples:
 %let list1 = a b ;
 %let list2 = c d ;
 %put %xprod (lv1=list1, lv2=list2);
 %put %xprod (lv1=list1, lv2=list2,osep=%str(,));

 LV1 and LV2 provide override to specify external variable name instead of lists.
 If one or more of the lists are empty then the empty list is returned.
 If the LV options are used then L1, L2, and XP_: should be avoided for variable names.

Credit:
    source code from Ian Whitlock, Names, Names, Names - Make Me a List
        (SGF 2007)   http://www2.sas.com/proceedings/forum2007/052-2007.pdf
        (SESUG 2008) http://analytics.ncsu.edu/sesug/2008/SBC-128.pdf
 */

 %local xp_i xp_j xp_1 xp_2 xp_list ;
 %if %length(&lv1) = 0 %then
 %let lv1 = l1 ;
 %if %length(&lv2) = 0 %then
 %let lv2 = l2 ;
 %do xp_i = 1 %to &sysmaxlong ;
   %let xp_1 = %qscan(%superq(&lv1), &xp_i, &sep1) ;
   %if %length(&xp_1) = 0 %then %goto endloop1 ;
   %do xp_j = 1 %to &sysmaxlong ;
     %let xp_2 = %qscan(%superq(&lv2), &xp_j, &sep2) ;
     %if %length(&xp_2) = 0 %then %goto endloop2 ;
     %if &xp_i = 1 and &xp_j = 1 %then
     %let xp_list = &xp_1&xp_2 ;
     %else
     %let xp_list = &xp_list&osep&xp_1&xp_2 ;
   %end ;
   %endloop2:
 %end ;
 %endloop1:
 %unquote(&xp_list)
%mend xprod ;
%macro zip(
       l1   =        /* first list */
     , lv1 =        /* external variable override for first list */
     , sep1 =%str( ) /* separator between the joined elements */
     , l2   =        /* second list */
     , lv2  =        /* external variable override for second list */
     , sep2 =%str( ) /* separator between the joined elements */
     , osep =%str( ) /* separator between new elements */
     ) ;

 /* %zip ( l1= a b , l2= c d ) produces ac bd

examples:
 %let list1 = a b ;
 %let list2 = c d ;
 %put %zip (lv1=list1, lv2=list2);
 %put %zip (lv1=list1, lv2=list2,osep =%str(,));
 %put %zip (l1=a b, l2=c d,osep =%str(,));

 If lists do not have same length shorter length used and warning to the log.
 Empty lists result in empty list and no message.
 If the LV options are used then L1, L2, and ZIP_: should be avoided for variable names.

Credit:
    source code from Ian Whitlock, Names, Names, Names - Make Me a List
          (SGF 2007)   http://www2.sas.com/proceedings/forum2007/052-2007.pdf
          (SESUG 2008) http://analytics.ncsu.edu/sesug/2008/SBC-128.pdf
 */

 %local zip_i zip_1 zip_2 zip_list ;
 %if %length(&lv1) = 0 %then
 %let lv1 = l1 ;
 %if %length(&lv2) = 0 %then
 %let lv2 = l2 ;
 %do zip_i = 1 %to &sysmaxlong ;
   %let zip_1 = %qscan(%superq(&lv1) , &zip_i, &sep1 ) ;
   %let zip_2 = %qscan(%superq(&lv2) , &zip_i, &sep2 ) ;
   %if %length(&zip_1) = 0 or %length(&zip_2) = 0 %then
   %goto check ;
   %if &zip_i = 1 %then
   %let zip_list = &zip_1&zip_2 ;
   %else
   %let zip_list = &zip_list&osep&zip_1&zip_2 ;
 %end ;
 %check:
 %if %length(&zip_1) > 0 or %length(&zip_2) > 0 %then
 %put WARNING: Macro ZIP - list lengths do not match - shorter used. ;
 %unquote(&zip_list)
%mend zip ;
